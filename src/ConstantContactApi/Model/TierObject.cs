/*
 * Constant Contact API v3
 *
 * Swagger build version 3.0.62
 *
 * The version of the OpenAPI document: 1.0.193
 * Contact: webservices@constantcontact.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = ConstantContactApi.Client.OpenAPIDateConverter;

namespace ConstantContactApi.Model
{
    /// <summary>
    /// The usage tier that is associated with a client&#39;s Constant Contact account and is used to calculate the monthly billing price.
    /// </summary>
    [DataContract(Name = "TierObject")]
    public partial class TierObject : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TierObject" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        public TierObject()
        {
        }

        /// <summary>
        /// Identifies the tier usage type that is associated with the billing plan.
        /// </summary>
        /// <value>Identifies the tier usage type that is associated with the billing plan.</value>
        /// <example>CONTACTS</example>
        [DataMember(Name = "usage_type", EmitDefaultValue = false)]
        public string UsageType { get; private set; }

        /// <summary>
        /// Returns false as UsageType should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeUsageType()
        {
            return false;
        }
        /// <summary>
        /// The number of active contacts (default) used within the current tier.
        /// </summary>
        /// <value>The number of active contacts (default) used within the current tier.</value>
        /// <example>10</example>
        [DataMember(Name = "current_usage", EmitDefaultValue = false)]
        public float CurrentUsage { get; private set; }

        /// <summary>
        /// Returns false as CurrentUsage should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeCurrentUsage()
        {
            return false;
        }
        /// <summary>
        /// The billing tier level that is associated with a client account. By default, the system determines the tier level to use based on the number of active contacts currently in the client account at the time of billing. Billing tiers may differ. The following shows an example billing tier: &lt;ul&gt;   &lt;li&gt;level &lt;code&gt;1&lt;/code&gt; &#x3D; 0 - 500 contacts&lt;/li&gt;   &lt;li&gt;level &lt;code&gt;2&lt;/code&gt; &#x3D; 501 - 1000 contacts&lt;/li&gt;   &lt;li&gt;level &lt;code&gt;3&lt;/code&gt; &#x3D; 1001 - ...&lt;/li&gt; &lt;/ul&gt;
        /// </summary>
        /// <value>The billing tier level that is associated with a client account. By default, the system determines the tier level to use based on the number of active contacts currently in the client account at the time of billing. Billing tiers may differ. The following shows an example billing tier: &lt;ul&gt;   &lt;li&gt;level &lt;code&gt;1&lt;/code&gt; &#x3D; 0 - 500 contacts&lt;/li&gt;   &lt;li&gt;level &lt;code&gt;2&lt;/code&gt; &#x3D; 501 - 1000 contacts&lt;/li&gt;   &lt;li&gt;level &lt;code&gt;3&lt;/code&gt; &#x3D; 1001 - ...&lt;/li&gt; &lt;/ul&gt;</value>
        /// <example>1</example>
        [DataMember(Name = "tier", EmitDefaultValue = false)]
        public int Tier { get; private set; }

        /// <summary>
        /// Returns false as Tier should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeTier()
        {
            return false;
        }
        /// <summary>
        /// The minimum number of active contacts for the tier level.
        /// </summary>
        /// <value>The minimum number of active contacts for the tier level.</value>
        /// <example>0</example>
        [DataMember(Name = "tier_min", EmitDefaultValue = false)]
        public float TierMin { get; private set; }

        /// <summary>
        /// Returns false as TierMin should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeTierMin()
        {
            return false;
        }
        /// <summary>
        /// The maximum number of active contacts for the tier level.
        /// </summary>
        /// <value>The maximum number of active contacts for the tier level.</value>
        /// <example>500</example>
        [DataMember(Name = "tier_max", EmitDefaultValue = false)]
        public float TierMax { get; private set; }

        /// <summary>
        /// Returns false as TierMax should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeTierMax()
        {
            return false;
        }
        /// <summary>
        /// The billing price set for the tier used to bill the client account each month.
        /// </summary>
        /// <value>The billing price set for the tier used to bill the client account each month.</value>
        /// <example>20</example>
        [DataMember(Name = "price", EmitDefaultValue = false)]
        public float Price { get; private set; }

        /// <summary>
        /// Returns false as Price should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializePrice()
        {
            return false;
        }
        /// <summary>
        /// The currency (ISO currency code) used to price the tier for a client account.
        /// </summary>
        /// <value>The currency (ISO currency code) used to price the tier for a client account.</value>
        /// <example>USD</example>
        [DataMember(Name = "currency_code", EmitDefaultValue = false)]
        public string CurrencyCode { get; private set; }

        /// <summary>
        /// Returns false as CurrencyCode should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeCurrencyCode()
        {
            return false;
        }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TierObject {\n");
            sb.Append("  UsageType: ").Append(UsageType).Append("\n");
            sb.Append("  CurrentUsage: ").Append(CurrentUsage).Append("\n");
            sb.Append("  Tier: ").Append(Tier).Append("\n");
            sb.Append("  TierMin: ").Append(TierMin).Append("\n");
            sb.Append("  TierMax: ").Append(TierMax).Append("\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  CurrencyCode: ").Append(CurrencyCode).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
